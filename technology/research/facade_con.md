## FACADE: A Compiler and Runtime for (Almost) Object-Bounded Big Data Applications 

### 简要总结

​	FACADE 是 [bloat-aware design](./bloat-aware_con.md) 的 future work，即在用户标注了 data class 的情况下将用户代码自动转换成能够“减少堆空间对象数量”的代码，以此优化大数据应用的内存使用。需要注意的是，FACADE 是编译层面的工作，因此才能实现 bloat-aware design 的**自动化**。

### 背景

​	背景与 Yak 和 bloat-aware 相同（尤其是 bloat-ware，基本一样）。作者将问题重点放在堆空间中的对象和引用过多，并且会随着 input dataset 规模增大而显著增加上。

### 实现思路

​	考虑到大数据场景下，JVM 堆空间中对象会显著增加，而这些对象又分别由 control path 和 data path 产生。因此，作者提出应当将 data storage 和 data manipulation 分隔开来，即数据应当存放在off-heap中，而堆中的对象应当用于控制（例如函数调用、参数传递和动态类型检查等，堆中对象被称为 facade，这与 bloat-aware提到的一致）。当需要访问数据时，由于堆中对象和off-heap中数据存在映射，因此可通过堆中对象间接访问数据（具体是使用指针）。而off-heap中的对象也具有“相同生命周期的对象聚集在一起”的特性，这里体现为一个迭代周期产生的对象被放在一起。通过证明，我们可以得出堆中用于控制的对象存在一定的上限（$O(t*n+p)$，t是线程数，n是数据类型数，p是存储数据用的page数）,它不会随着输入数据规模的增大而显著增加。因此堆空间的内存回收变得异常迅速，且由于对象头和引用导致的空间开销也会大大减少。在使用 FACADE 进行代码转换前，用户需要标记处 data class，即标记处哪些类需要进行代码转换。换句话说，即哪些类的实例需要放到 off-heap 的 page中。位于堆空间中的对象称为 heap，它用于控制（传递参数，函数调用等），和off-heap中的数据采用指针的形式绑定。

### 思考与启发

​	从整体上看，FACADE 是 bloat-aware design 的进一步优化。在原有基础上，作者加入了 一个编译环境使得用户的代码能够自动转换为符合 FACADE 要求的代码，具体转换规则见 Section 2.2。总体而言，堆空间中的facade（控制对象）用于表示 off-heap 中的数据，它们之间使用指针相连，而所有对 facade 的操作都被编译为对 off-heap 中 page 的操作。一轮迭代中用到的数据存放在同一page中，当迭代结束时，page被回收。堆空间中的facade对象具有数量少、不随输入数据的规模而变化以及生命周期较短等特点，GC在回收这些对象时产生的暂停更少，因对象头和对象引用带来的内存消耗也更少。需要注意的是，大部分人工开销集中在找出 data path（data class）以及配置执行环境中，虽然作者提出作为新手也能找出 data path，但我们对这点仍然存疑，即我们希望能够减少人工成本，对用户隐藏底层的细节。这篇文章带给我的启发如下：

- 数据密集型（data-intensive）应用仍然是大数据处理的主流，我们的研究工作也放在数据密集型大数据处理应用的优化上（正如本文所说，优化的是data path）；
- 越底层的修改，对上层用户就越透明。但在底层总有一些数据无法获取，例如本文提到的data path，这是与应用相关的，因此需要用户或者其他手段（例如程序分析）提供。我们的工作是想找到一些内存通用模式，并在此基础上进行优化，尽管无法优化全部内容，但能优化具有某些通用内存模式的一类应用，这也是值得的。如果我们的工作需要涉及到某些数据处理框架层无法提供的信息，必要时也需要从应用程序中得到该信息；
- iteration是大数据处理应用的一大显著特征，不同于每个应用表现的具体特征，这属于通用模式，可以从数据处理框架层拿到相应的指导信息（什么时候迭代开始，什么时候结束等），从而指导优化内存的使用。